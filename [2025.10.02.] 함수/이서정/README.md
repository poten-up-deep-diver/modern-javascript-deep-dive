## 자바스크립트 함수

### 1. 함수를 사용하는 이유

프로그래밍에서 같은 동작을 여러 번 반복해야 하는 경우가 많다. 이때 함수를 사용하면 한 번 정의한 코드를 여러 번 호출할 수 있기 때문에 **코드의 중복을 줄이고 재사용성을 높일 수 있다.**

- **함수 사용의 장점**
  - **중복 억제**: 같은 코드를 반복해서 작성하지 않아도 된다.
  - **유지보수 용이**: 수정해야 할 때 함수 내부만 고치면 된다.
  - **신뢰성 향상**: 중복된 코드에서 발생할 수 있는 실수를 줄일 수 있다.
  - **가독성 향상**: 함수 이름만 보고도 코드의 의도를 쉽게 파악할 수 있다.

### 2. 함수 리터럴

자바스크립트에서 함수는 **객체 타입의 값**이다. 그래서 함수를 생성하는 방법도 "리터럴" 표기법을 따른다.

- **함수 리터럴의 구성 요소**
  - `function` 키워드
  - 함수 이름 (생략 가능)
  - 매개변수 목록 (괄호 `()` 안에 쉼표로 구분)
  - 함수 몸체 (중괄호 `{}` 안에 코드 작성)

```jsx
// 함수 리터럴 예시
const add = function (x, y) {
  return x + y;
};
```

- **일반 객체와 다른 점:**
  - 객체는 단순히 값의 집합이지만, 함수는 호출이 가능하다.
  - 함수는 함수 객체만의 고유한 프로퍼티(예: `name`, `length`)를 가진다.

### 3. 함수 정의

자바스크립트에서 함수를 정의하는 방법은 4가지가 있다.

- 함수 선언문
- 함수 표현식
- 생성자 함수
- 화살표 함수(ES6)

### 4. 함수 선언문

함수 선언문은 반드시 함수 이름을 작성해야 한다.

- **자바스크립트 엔진 해석 방식**
  - 중괄호 `{}`는 문맥에 따라 블록문일 수도 객체 리터럴일 수도 있다.
  - **함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석**한다.
  - **변수에 할당하거나 피연산자로 쓰면 함수 표현식으로 해석**한다.
- **호출 방식의 차이**
  - 함수 이름은 함수 몸체 안에서만 유효한 식별자다.
  - 실제 함수 호출은 함수 객체를 가리키는 식별자를 통해서만 가능하다.
  ```jsx
  // 자바스크립트 엔진의 내부 동작 (개념적 이해)
  function add(x, y) {
    return x + y;
  }

  // 코드 엔진 해석 순서
  // 1. 함수 객체 생성 (함수 이름: add)
  // 2. 동일한 이름의 식별자 'add' 생성 (암묵적)
  // 3. 식별자 'add'가 함수 객체를 가리킴

  console.log(add(2, 3)); // 5
  // 'add'는 식별자이며, 이를 통해 함수 객체에 접근하여 호출
  ```

💡 **함수 선언문은 언제 사용할까?**

- 호이스팅(hoisting)이 필요할 때
- 전역 또는 블록스코프(`{}`)에서 명확하게 정의되거나 관리가 필요할 때
- 자기 자신을 호출이 필요한 경우 선언식이 안정적
- 직관적이므로 코드 가독성을 높이고 싶을 때

### 5. 함수 선언문과 함수 표현식의 비교

```jsx
// 함수 선언문
console.log(greet("김ㅋㅋ")); // 선언 전 호출 가능

function greet(name) {
  return `안녕하세요, ${name}님!`;
}

// 함수 표현식
console.log(sayHello("김ㅋㅋ")); // ReferenceError - 호이스팅 안됨.

const hello = function sayHello(name) {
  return `안녕, ${name}!`;
};

console.log(hello("김ㅋㅋ")); // 안녕, 김ㅋㅋ님! - 선언 후 호출 가능
console.log(sayHello("김ㅋㅋ")); // 외부에서 함수명 접근 불가. 내부에서만 유효
```

💡**함수 표현식은 언제 사용할까?**

- 익명 함수 표현식은 일반적으로 많이 사용하는 함수로 콜백 함수, 이벤트 처리할 때 자주 쓰임.
- 기명 함수 표현식은 디버깅 시 오류 메세지에 함수명이 표시됨. 자기 자신을 호출이 필요할 때 사용.
- **익명 함수 표현식 예시**
  ```jsx
  // 익명 함수 표현식 활용 예시
  const numbers = [1, 2, 3, 4, 5];

  // 콜백 함수로 사용
  const doubled = numbers.map(function (num) {
    return num * 2;
  });

  // 이벤트 핸들러로 사용
  button.addEventListener("click", function () {
    console.log("버튼 클릭!");
  });
  ```

### 6. 함수 생성 시점과 함수 호이스팅

호이스팅(Hoisting)은 변수나 함수 선언이 스코프(범위)의 최상단으로 끌어올려지는 것처럼 동작하는 자바스크립트의 특성이다.

- 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
- 코드 어디에서든 함수를 호출 할 수 있다.

### 7. 다양한 함수의 형태

- **즉시 실행 함수 : 함수 정의와 동시에 즉시 호출되는 함**
  - 익명 함수를 사용하는 것이 일반적이며 단 한번만 호출되고 다시 호출 할 수 없다.
  - 변수나 함수 이름의 충돌을 방지할 수 있다.
  - 즉시 실행 함수의 예시
    ```jsx
    // 기본 형태
    (function () {
      console.log("즉시 실행!");
    })();

    // 매개변수 전달
    (function (name) {
      console.log(`안녕하세요, ${name}님!`);
    })("김ㅋㅋ"); // "안녕하세요, 김ㅋㅋ님!"

    // 반환값 사용
    const result = (function (a, b) {
      return a + b;
    })(10, 20);

    console.log(result); // 30
    ```
- **재귀 함수 : 자기 자신을 호출하는 함수**

  - 자신을 무한 호출하므로 탈출 조건을 반드시 작성해야 한다.
  - 예시
    ```jsx
    // 카운트다운 예시
    function countdown(n) {
      if (n < 0) return; // 탈출 조건

      console.log(n);
      countdown(n - 1); // 재귀 호출
    }

    countdown(5); // 5, 4, 3, 2, 1, 0
    ```

- **중첩 함수 : 함수 내부에 정의된 함수**
  - 외부 함수 내부에서만 호출이 가능하다.
    ```jsx
    function outer(x) {
      // 중첩 함수 (내부 함수)
      function inner(y) {
        return x + y;
      }
      return inner(10);
    }

    console.log(outer(5)); // 15
    console.log(inner(10)); // ReferenceError - 외부에서 접근 불가
    ```

### 마무리

자바스크립트에서 함수는 코드의 중복을 억제하고 재사용성을 확보하며 프로그램의 구조적 완성도를 높이는 핵심 도구이다.

함수 리터럴, 선언문, 표현식, 화살표 함수 등 다양한 정의 방식은 실행 시점과 호이스팅, 스코프 처리 방식에서 차이를 보이며 각각의 특성을 고려해 사용해야 한다.

즉시 실행 함수, 재귀 함수, 중첩 함수, 콜백 함수 등은 상황에 맞는 설계와 활용을 통해 프로그램의 안정성과 가독성을 강화한다.
