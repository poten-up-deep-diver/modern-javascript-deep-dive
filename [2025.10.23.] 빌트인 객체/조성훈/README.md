# DOM Node와 HTML Attribute의 차이

## 🤨 들어가기 전

프로젝트를 진행할 때, 직접 DOM 요소의 접근하여 클래스 속성이나 dataset, src를 지정하며 "왜 HTML 속성이랑 다르게 작성하는걸까"라는 궁금증을 가졌다.

이후 리액트를 공부하면서, 자바스크립트 확장 문법 JSX를 사용하며 확실히 DOM Node와 HTML Attribute 차이에 대해 짚고 넘어가야겠다 느꼈다. 속성 작성에 대한 부분은 자바스크립트 문법이기 때문에 예약어와 충돌이 되지 않기 위해 제작되어 있는 것은 배웠지만, 뭔가 찜찜한 그 기분.

## (복습) JSX와 DOM Node

어제 우리는 JSX 문법을 사용해서 우리가 화면에 그리고자 하는 내용을 직접 작성했다. 이 코드가 브라우저가 실제로 이해하고 화면에 보여주는 **DOM Node**가 되기까지, 중간에 어떤 과정이 일어날까?

JSX가 트랜스파일에 의해 React.createElemet() 함수 호출로 변환되고, 이것이 React 내부에서 가상 DOM을 만들고 관리하는 기반이 된다. 이 가상 DOM의 변경 사항이 최종적으로 실제 브라우저의 DOM Node를 업데이트 하는 것. JSX는 브라우저가 직접 이해할 수 있는 코드가 아니다.

탑골공원을 상상해보자..

- JSX : 뒤에서 이렇게 둬라 , 저렇게 둬라 훈수 두는 할아버지 (선언적 기술)
- Virtual DOM: 실제 장기판에 장기를 두는 플레이어 (실제 DOM의 복사본, 변경 사항을 효율적으로 관리하고 비교)
- DOM Node: 실제 장기판 (브라우저가 HTML을 해석하여 브라우저 메모리에 생성한 실제 객체)

| 구분      | JSX                                           | Virtual DOM                                      | DOM Node                             |
| --------- | --------------------------------------------- | ------------------------------------------------ | ------------------------------------ |
| 본질      | JavaScript를 위한 선언적 문법                 | React 내부에서 관리되는 메모리상의 가상 트리     | 브라우저 메모리에 존재하는 실제 객체 |
| 존재 위치 | 개발자의 소스 코드 및 React Element 변환 결과 | React 엔진 내부 메모리                           | 브라우저의 DOM Tree                  |
| 역할      | UI 구조와 요소를 선언적으로 정의              | 변경 사항을 효율적으로 계산 및 비교              | 실제 UI 렌더링과 상호작용 처리       |
| 비유      | 설계도를 작성하는 사람(또는 훈수 두는 설계자) | 장기판 위에서 실제로 수를 두며 비교하는 플레이어 | 실제 장기판(브라우저에 표시된 결과)  |

DOM Node는 브라우저가 HTML을 해석하여 브라우저 메모리에 생성한 실제 객체라고 했다. 이 부분을 잘 기억해두자.

## JavaScript 객체의 분류

브라우저의 DOM Tree 안에 위치한 DOM Node? 점점 미궁 속으로 빠져간다. 다시 책의 내용을 복습해보자.

![](https://poiemaweb.com/img/objects.png)

자바스크립트 엔진은 세 가지 종류의 객체를 다룬다.

1. **표준 빌트인 객체 (Standard Built-in Objects):**
   ECMAScript 사양에 정의되어 있어, 어떤 자바스크립트 환경에서도 항상 사용할 수 있는 객체
   `String`, `Number`, `Array`, `Date`, `Math`, `JSON`, `Promise`, `Object` 등.

2. **호스트 객체 (Host Objects):**
   자바스크립트 코드를 실행하는 환경, 즉 브라우저나 노드제이에스에서 제공하는 특정 환경에 종속적인 객체
   브라우저 환경: `DOM`, `BOM`, `Canvas`, `fetch`와 같은 클라이언트 사이드 Web API
   Node.js 환경: Node.js 고유의 API

3. **사용자 정의 객체 (User-defined Objects):**
   개발자가 직접 정의한 클래스나 객체 리터럴 등으로 생성한 객체

DOM Node는 브라우저라는 호스트 환경이 자바스크립트 엔진에 제공하는 호스트 객체, JSX는 이 호스트 객체를 효율적으로 생성하고 관리하기 위한 React 라이브러리의 선언적 도구다.

## 🤨 그래서 왜 다른거냐고!!!

방금 전, DOM Node는 브라우저가 HTML을 해석하여 브라우저 메모리에 생성한 실제 객체라고 했다.
해당 문장에서 이미 **DOM Node는 기존 HTML을 해석한다**..

1. 기존에 있는 애를 왜 굳이 해석하지?
2. 왜 브라우저 메모리에 존재해야 하지?

여기에 해답이 있는 것 같다.

### DOM의 탄생 이유

자바스크립트의 역사를 타고 올라가면 그 존재 이유를 알 수 가 있다. JS는 정적인 HTML/CSS 웹사이트에 동적인 기능을 추가하기 위해 등장했다고 배웠다. 그 과정에서 DOM이 필수적으로 필요하게 된 것이다.

| 단계          | 웹 상태                                          | 필요성                                                                                  | 해결책                           |
| ------------- | ------------------------------------------------ | --------------------------------------------------------------------------------------- | -------------------------------- |
| 초기 (정적)   | HTML과 CSS: 문서를 보여주는 역할 (내용과 스타일) | 사용자의 상호작용에 반응하고, 내용이나 스타일을 실시간으로 변경하고 싶음                | JavaScript 등장                  |
| 상호작용 필요 | JavaScript 등장: 동적인 기능은 생김              | JavaScript가 HTML 요소(Element)를 객체처럼 인식하고 접근할 수 있는 통일된 방법이 필요함 | DOM (Document Object Model) 정의 |

DOM은 HTML 문서의 내용을 객체화하여 **JS가 접근하고 조작할 수 있도록 해주는 중개자 역할**을 한다 (마치 리액트와 DOM의 관계를 보는 것 같다!) HTML은 그냥 텍스트 파일에 불과하다. JS가 동적으로 이 버튼의 색깔을 바꿔버려 라고 명령하려면, **그 버튼이 JS가 이해할 수 있는 데이터 구조(객체)로 메모리에 올려줘야 한다.**

자바스크립트는 HTML 요소를 직접 이해할 수 없다. HTML 문서 요소를 읽어서 객체(Node)들의 트리(Tree) 구조로 메모리에 저장해야, 자바스크립트가 프로그래밍 방식으로 `document.getElementById()`, `.style.color = 'blue'` 그 객체에 접근하여 **속성(Property)**을 읽거나 **메서드(Method)**를 실행하여 실제 화면에 변화를 줄 수 있기 때문이다.

### (복습) Node와 Element 개념 정리

DOM은 전체 문서를 구성하는 모든 구성 요소를 Node라는 가장 기본적인 단위로 취급한다.

1. **Node 노드:**
   DOM 트리를 구성하는 가장 근본적인 객체: `Element Node` (태그 자체), `Text Node` (태그 안의 글자), `Comment Node` (주석) 등.

2. **Element 요소:**
   HTML 태그(`html`, `body`, `div`, `p`)에 해당하는 노드. 우리가 주로 조작하는 대상이며 리액트 애플리케이션을 구성하는 가장 작은 단위.

### 그래서 문법적 충돌이 일어나는 것

자바스크립트는 class를 객체 클래스를 정의하는 예약어로 사용한다. DOM 객체를 만들 때, HTML 속성(`class`, `for`)을 그대로 객체의 속성으로 사용하면 문법적 충돌이 발생한다.

따라서, DOM API와 React의 JSX에서는 충돌을 피하기 위해 `class` 대신 `className`을, `for` 대신 `htmlFor`와 같이 이름을 변경하여 사용하게 된 것. DOM 객체가 자바스크립트 객체의 규칙을 따라야 하기 때문에 발생하는 현상인 것. (참 피곤하다)

### DOM 객체와 BOM 객체

DOM은 HTML 문서를 제어하기 위해, BOM은 브라우저 창과 환경을 제어하기 위해 필요하다.

DOM과 BOM은 모두 브라우저 환경(호스트 객체)에서 JavaScript가 웹페이지와 브라우저 자체를 제어할 수 있도록 제공되는 객체다.

1. **DOM (Document Object Model) :**
   웹페이지의 내용과 구조(HTML)를 객체로 만들어 제어할 수 있게 돕는 객체

   핵심 객체: document 객체. 이 객체를 통해 HTML 요소(Node)들에 접근! HTML 요소의 내용, 스타일, 구조(추가/삭제).

2. **BOM (Browser Object Model) :**
   웹페이지의 내용이 아닌, 브라우저 창 자체나 브라우저 환경에 기능을 제공하는 객체

   핵심 객체: window 객체 (모든 BOM 객체의 최상위 객체이자 전역 객체)!

- location: 현재 페이지의 URL 정보
- history: 브라우저 방문 기록 (뒤로 가기/앞으로 가기)
- screen: 사용자 모니터 정보
- navigator: 브라우저 정보 (종류, 버전 등)
- setTimeout, alert, prompt 등

## DOM은 결국 Property와 Method로 이루어진 객체 구조

당연했다. Object Model == 객체 구조... 이런!

DOM은 HTML 문서를 객체들의 트리 구조로 메모리에 표현하며, 이 객체들(Ndoe)가 가진 정보는 속성과 메소드로 저장 및 표현된다.

재밌었던 점은, 이전에 배운 [데이터 프로퍼티 vs 접근자 프로퍼티](../../[2025.10.17.]%20프로퍼티%20어트리뷰트//조성훈/README.md) 에서 나왔듯이 className, id, src 와 같은 프로퍼티 역시 단순 데이터 프로퍼티가 아니라 접근자 프로퍼티로 구현된다는 점이다.

실제에는 더욱 복잡한 작업을 수행하겠지만, 단순화하여 표현하면 다음과 같은 흐름이지 않을까?

[DOM 객체 개념 구조 이해하기](./example/domExample.js)

## 결론

HTML은 단순 텍스트 파일, DOM은 자바스크립트 실행을 위한 객체 구조.

1. **HTML 파싱:** 브라우저는 HTML 파일을 읽고(파싱) DOM Tree라는 객체 모델을 메모리(Host Object 영역)에 구축한다.
2. **객체 생성:** HTML의 모든 요소는 HTMLElement나 TextNode 같은 JavaScript 객체로 변환한다.
3. **정보 저장:** 이 객체들은 HTML 태그의 정보를 다음과 같이 저장한다:

- 구조: 부모/자식/형제 노드를 가리키는 포인터( parentNode, children 속성).
- 데이터: HTML 속성 값(id, src, href)을 대응되는 DOM 프로퍼티(id, src, href)에 저장. 이들 중 상당수가 위에서 설명한 접근자 프로퍼티로 구현
- 기능: 조작을 위한 메서드(appendChild, remove, querySelector).
