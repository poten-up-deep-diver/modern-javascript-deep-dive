## 들어가기 전

개발 공부를 하다보면, 항상 동기와 비동기에 대한 차이를 설명해보라 하면 꿀먹은 벙어리가 되었다. 개념적으로는 두가지 은유를 통해 이해했다. 아래 비유를 바탕으로 JS가 비동기 처리를 해야 하는지, 다른 개념들과 어떻게 연결되는지 알아보자!

- 친구와의 약속을 잡을 때
  - "야" -> "응?"
  - "너 토요일날 언제 시간 돼" -> "9시"
  - "나 9시 안돼" -> "그럼 12시?"
- 친구와의 약속을 비동기 방식으로 잡을 때
  - "야 나 토요일날 12시~4시 사이에 시간이 되는데, 만날 수 있어?"
- 배달의민족에서 주문한 음식이 집에 도착하기까지 걸리는 과정
  - (가게) 주문 수락 -> 조리 시작
  - (가게) 중간중간 손님 응대, 간단한 레지 업무
  - (라이더) 라이더 출발 -> 가게 도착
  - (가게) 조리 끝 -> 음식 내놓음
  - (라이더) 음식 픽업 -> 배달 시작

## 동기 vs 비동기

### 친구랑 약속잡는 2가지 방법

약속 시간을 찾는 일이 오래 걸리는 일 (네트워크 통신) 이라고 가정해보자. 동기 방식은 친구가 캘린더를 들여다보고 답장을 하기까지 내가 아무것도 하지 않고 채팅방에 기다리는 것. 하지만, 비동기 방식은 친구에게 캘린더 확인을 맡기고 나는 그동안 설거지를 해두는 것과 같음.

| 구분   | 동기적 약속 (Synchronous)                                                                                                                      | 비동기적 약속 (Asynchronous)                                                                              |
| ------ | ---------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| 방식   | 순차적 처리 (Blocking)                                                                                                                         | 비순차적 위임 (Non-Blocking)                                                                              |
| 대화   | 나: "토요일 9시 돼?" (질문) $\rightarrow$ 친구 답변을 기다림 $\rightarrow$ 친구: "안 돼." (응답) $\rightarrow$ 나: "그럼 12시 돼?" (다음 질문) | 나: "토요일에 12시부터 4시 사이에 되는 시간 찾으면 나에게 알려줘 (콜백)." $\rightarrow$ 바로 다음 일 시작 |
| **JS** | JS 엔진(나)이 이전 작업(친구 답변)이 완료될 때까지 대기 (Blocking)                                                                             | JS 엔진(나)이 오래 걸리는 작업(시간 찾기)을 외부(Web API)에 위임하고, 다음 코드를 즉시 실행               |

### 우리 집에 김치짜글이가 오기까지

자바스크립트 엔진은 기본적으로 싱글 스레드, 한 번에 한 가지 일만 처리할 수 있다. 한 명의 요리사만 있는 작은 가게라고 생각해보자. 위임에 관한 부분은 밑에서 자세히 알아보겠다.

- 손님 응대, 간단한 카운터 계산 : 동기 작업
- 조리, 배달 등 시간이 오래 걸리는 작업: 비동기 작업

### 비동기 작동 원리

자바스크립트가 싱글 스레드임에도 불구하고 비동기 처리를 수행할 수 있는 것은, 위임과 외부 환경 덕분이다. 비동기 처리는 세가지 핵심 구성 요소의 협업을 통해 이루어지며, 이 세가지가 JS엔진과 WebAPI를 연결해주는 장치이다.

1. 콜 스택: 엔진이 코드를 실행하는 단 하나의 작업 공간
2. 웹 API: 오래 걸리는 작업을 위임하는 외부 브라우저 환경
3. 이벤트 루프: 비동기 작업이 완료되면 콜 스택으로 바로 돌아가지 않고 잠시 Queue에서 대기

---

| **구분**      | **동기 (Synchronous)**                                         | **비동기 (Asynchronous)**                                                    |
| ------------- | -------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| **작업 방식** | **순서대로** 한 번에 하나씩 처리 (코드가 작성된 순서대로 실행) | 오래 걸리는 작업은 **위임**하고 바로 다음 작업으로 넘어감                    |
| **특징**      | 직관적이고 이해하기 쉬움                                       | 비선형적이어서 코드 흐름을 파악하기 어려울 수 있음                           |
| **주요 문제** | 오래 걸리는 작업 시 **블로킹(Blocking)** 발생                  | 콜백 지옥(Callback Hell) 및 순서 보장의 어려움 (Promise, async/await로 해결) |
| **작업 주체** | **JS 엔진 (Call Stack)**                                       | **Web API**에 위임 후, **Event Loop**로 결과 처리                            |

```js
// A. 동기 작업: 콜 스택에 쌓여 즉시 실행
console.log("시작");

// B. 비동기 작업: Web API로 위임 (2초 타이머 시작)
setTimeout(() => {
  console.log("2. 비동기 콜백 함수 실행");
}, 2000);

// C. 동기 작업: A가 끝난 후 B의 타이머가 돌아가는 동안 즉시 실행
console.log("1. 다음 작업 완료");

// D. 동기 작업: C가 끝난 후 즉시 실행
console.log("종료");
```

**✅ 출력 순서:**

1. `시작` (A)
2. `1. 다음 작업 완료` (C)
3. `종료` (D)
4. (2초 후) `2. 비동기 콜백 함수 실행` (B)

---

## 비동기 콜백

우리는 WebAPI로 위임하여 외부 브라우저 환경에서 비동기 작업이 메인 스레드를 막지 않고 실행되는 것을 알게 되었다. 하지만, 비동기 특성 때문에 한 가지 문제가 생긴다.

**문제**
서버 통신처럼 시간이 얼마나 걸릴지 정확히 알 수없는 비동기 작업이 있고, 그 작업이 완료된 후에만 결과를 가지고 후처리를 해야 할 때.. 자바스크립트 엔진에게 작업이 끝나면 이 코드를 실행해줘 라고 약속할 수 있을까?

### 콜백 함수

콜백함수는 그저 다른 함수의 인자로 전달되는 함수이다. 콜백함수를 비동기 작업을 처리하는 함수(`setTimeout` `fetch` 등..)에 전달하면, 그걸 비동기 콜백함수라 부르는 것.

비동기 작업이 완료되는 시점을 보장하고, 그 이후 순서대로 실행되어야 할 후처리 코드를 명확하게 정의하기 위함이다.

### 콜백 지옥

여러 개의 비동기 작업이 연속적으로 실행되어야 한다면? 콜백함수가 계속 중첩되며 들여쓰기 형태로 깊숙이 들어가게 되며, 이 현상을 콜백 지옥이라 부른다.

가독성이 저하되며 한 눈에 로직 흐름을 파악하기 어려워진다. 또한, 중간의 하나 로직만 변경하거나 오류 수정 시, 찾아내고 수정하기 까다로워진다.

> 이 문제점을 해결하기 위해 ES6에서 Promise라는 문법이 도입되었다!

## Promise, 약속

프로미스는 비동기 작업의 성공이나 실패를 나타내는 자바스크립트 객체이다. 비동기 작업의 진행 상황을 "상태"로 관리한다는 점이 가장 큰 장점이자 특징이다.

콜백 방식은 비동기 작업이 성공했는지, 실패했는지를 개발자가 직접 확인하고 처리해야 했지만, 프로미스는 이 과정을 표준화했다,

프로미스는 비동기 작업 결과에 따라 반드시 아래 3가지 상태 중 하나를 가지게 된다

1. 대기 Pending
2. 성공 Fulfilled
3. 실패 Rejected

기존 콜백 방식에서는 작업 끝나면, 이 함수를 실행해줘에 대한 명확한 지침이었고, 프로미스는 "미래의 결과, 상태에 따른 약속"을 만드는 것과 같다.

1. 항상 Pending에서 시작하여 단 한 번만 Fulfilled나 Rejected 상태로 전환
2. 한 번 상태가 확정되면(Settled),, 그 상태와 결과값은 절대 변하지 않음

이를 활용해, `then` `catch` `final` 을 연결하여 비동기 작업을 순차적으로 처리할 수 있다.

### 1. 프로미스 생성 (`new Promise`)

비동기 함수를 만들 때는 `new Promise()` 생성자를 사용하며, 인자로 `executor` 함수를 받습니다. 이 `executor` 함수는 `resolve`**와 **`reject`\*\*라는 두 함수를 인자로 받는다.

- `resolve(값)`: 비동기 작업이 성공했을 때 호출하며, 프로미스의 상태를 Fulfilled로 바꾸고 결과값을 담음
- `reject(에러)`: 비동기 작업이 실패했을 때 호출하며, 프로미스의 상태를 Rejected로 바꾸고 에러를 담음

### 2. 프로미스 체이닝 (Promise Chaining)

프로미스의 가장 강력한 특징은 `.then()` 메서드가 항상 새로운 프로미스를 반환한다는 점입니다. 이를 통해 여러 비동기 작업을 수평적으로 연결하는 체이닝이 가능해진다.

- `.then(성공 콜백)`: 프로미스가 Fulfilled 상태가 될 때 실행될 함수를 등록합니다. 이때 콜백 함수는 이전 프로미스의 결과값(Value)을 인자로 받습니다.
- `.then()`의 반환 값:
  - `then` 안에서 프로미스를 반환하면, 다음 `.then`은 그 프로미스가 완료될 때까지 기다렸다가 실행됨
  - `then` 안에서 일반 값을 반환하면, 그 값은 즉시 프로미스로 감싸져 다음 `.then`으로 전달

### 3. 오류 처리 (Error Handling)

`.catch()`는 프로미스 체인에서 발생한 모든 Rejected 상태를 처리하는 역할을 한다.

- `.catch(실패 콜백)`: 체인 중간에 오류가 발생하면 남은 `.then()` 블록은 모두 건너뛰고 가장 가까운 `.catch()` 블록이 실행
- 중간 캐치: 체인 중간에 `.catch()`를 넣어 특정 단계의 오류만 처리하고, 오류 대신 다른 값(예: 대체 상품)을 리턴하면, 체인이 오류 없이 다시 정상 흐름으로 이어짐..

> 이를 통해 성공 로직과 실패 로직을 분리하여 가독성을 챙길 뿐만 아니라, 체인 어디에서든 오류가 발생하면 나머지 .then() 블록을 건너뛰고 체인 맨 끝에 붙어있는 .catch()로 오류가 자동으로 전달된다.

## Promise의 효율을 높이는 Static 함수들

여러 개의 비동기 작업을 동시에(병렬로) 처리하여 시간을 획기적으로 단축하는 방법들이 있다.

**문제**
만약 유저 이름 가져오기`1초`와 할 일 목록 가져오기`2초`라는 두 개의 작업이 서로 아무런 연관이 없는 독립적인 작업이라면, 프로미스 체이닝으로 순차적 실행할 경우 `3초`가 걸린다.

위 순차 처리를 병렬 처리로 수행한다면, `1초`를 벌 수 있는 셈이다. 자바스크립트는 기본적으로 싱글 스레드로 작동하는데, 어떻게 여러 개의 비동기 작업을 병렬로 처리할 수 있는 것일까?

1. 위임: 자바스크립트 엔진이 비동기 함수를 만나면, 해당 작업을 브라우저나 node,js 환경의 백그라운드 스레드에 위임한다.
2. 동시 실행: 이 백그라운드 스레드들이 여러개의 작업을 동시 처리하고, JS엔진은 이 작업이 끝날 때까지 기다리지 않고 다음 동기 코드를 실행한다.
3. 결과 수집: 작업들이 백그라운드에서 끝나면, JS는 이 결과물을 한 번에 모아 처리한다.

### Promise.all

위 메소드는 인자로 받은 모든 프로미스들이 전부 성공 resolve할 때까지 기다렸다, 결과들을 배열 형태로 반환한다. 병렬 처리에 있어 효율적이지만, All or Nothing이라는 실패 원칙을 가지고 있다. 10개의 프로미스를 Promise.all에 전달했는데, 1개라도 실패시 Promise.all은 즉시 실패 상태가 되며, 나머지 9개의 비동기 작업 결과와 상관없이 사전에 정의한 catch() 블록으로 이동한다.

_나머지 9개 작업이 강제로 중단되는 매커니즘이 아니다. Promise.all은 1개의 실패를 발견하는 즉시 결과 수집 행위를 멈추고 catch() 블록으로 이동하지만, 9개의 작업은 계속 실행되어 완료될 때까지 동작한다.. 다만 그 결과값이 무시될 뿐!_

### Promise.allSettled

만약 10개의 독립적인 API 호출을 병렬로 진행하는데, 2~3개가 실패하더라도 성공한 7~8개의 결과는 반드시 수집해야 하는 상황이라면?

`Promise.allSettled`는 인자로 전달된 모든 프로미스가 성공하든 실패하든 관계없이 모든 작업이 완료될 때까지 기다린다. 완료된 후에는 각 프로미스의 상태와 결과가 담긴 배열을 반환한다.

| **특성**      | **Promise.all**                          | **Promise.allSettled**                     |
| ------------- | ---------------------------------------- | ------------------------------------------ |
| **목표**      | 모든 작업이 **성공**해야 함              | 모든 작업의 **완료** 상태를 확인해야 함    |
| **종료 조건** | **가장 빠른 실패** 또는 **모든 성공**    | **모든 프로미스가 완료(Settled)**될 때까지 |
| **반환값**    | 성공값의 `배열` (하나라도 실패하면 오류) | **상태 객체 배열** (모든 결과 포함)        |

### Promise.any & Promise.race

위 2개의 메소드는 전체 수집이냐, 개별 수집이냐에 대한 차이가 가장 크다. "가장 먼저" 속도를 기준으로 동작하는 메소드는 any와 race가 있다.

> any: 난 아무거나 좋아: 가장 먼저 성공한거(fulfilled) 아무거나
> race: 경주: 가장 먼저 완료된거(settled)

| **메서드**               | **목표 및 용도**                                                                   | **실패 원칙**                                             |
| ------------------------ | ---------------------------------------------------------------------------------- | --------------------------------------------------------- |
| **`Promise.all`**        | **모든 작업의 성공**이 필수일 때 (예: 필수 데이터 묶음 가져오기)                   | **하나라도 실패하면** 즉시 전체 실패                      |
| **`Promise.allSettled`** | **모든 작업의 결과**를 알고 싶을 때 (성공/실패 무관, 예: 배치 작업 후 보고서 작성) | 모든 프로미스가 완료될 때까지 기다림                      |
| **`Promise.race`**       | **가장 빠른 결과**를 원할 때 (예: 여러 CDN 중 응답이 가장 빠른 서버 사용)          | **가장 빠른 완료(성공 또는 실패)**를 따라 즉시 종료       |
| **`Promise.any`**        | **가장 빠른 성공**을 원할 때 (예: 여러 백업 서버 중 하나라도 응답하면 됨)          | **모두 실패해야** 전체 실패 (성공이 하나라도 있으면 성공) |

## async/await 마법의 문법

> async와 await는 이 프로미스 코드를 마치 일반적인 동기 코드처럼 보이게 만들어주는 문법적 설탕이다. 새로운 개념보다는 프로미스를 더 쉽게 쓰는 방법이다.

`.then().then().then().then()`으로 이어지는 수평적인 체이닝은 코드가 길어지면 가독성이 떨어지게 된다. async/await를 사용하면 비동기 로직이 위에서 아래로 흐르는 동기 코드 형태로 작성되기 때문에, 읽는 순서가 보장되며 `try...catch` 구문을 통해 에러를 처리할 수 있게 된다.

### async

`async`는 함수 선언 시 `function` 키워드 앞에 붙는다. 해당 키워드가 붙은 함수는 항상 프로미스 객체를 반환한다. 문자열과 같은 일반 값을 리턴하면, JS는 내부적으로 이 값을 성공 상태의 프로미스로 감싸서 반환한다. 이미 프로미스 객체를 리턴한다면, 그 프로미스 객체가 그대로 반환된다.

### await

`await` 키워드는 이름 그대로 기다리다 라는 뜻. 오직 프로미스 객체 앞에서만 사용 가능하며, 해당 프로미스가 성공할 때까지 함수의 실행을 멈추는 역할을 한다.

### try...catch를 이용한 오류 처리

`async/await`에서 `try...catch`를 사용하는 것은 오류 발생 시 남은 코드를 건너뛰고 오류 처리 블록으로 이동한다는 측면에서 `.catch()`와 유사한 역할을 한다.

`async` 함수 내부에 여러 개의 `await` 호출이 있을 때, `try...catch` 블록이 단 하나만 있어도, 이 블록은 그 안에 있는 모든 `await`에서 발생하는 오류(프로미스의 `reject`)를 잡아낼 수 있다. 프로미스가 reject가 되면 try 블록 내의 코드는 즉시 건너 뛰어지고 바로 catch 블록으로 이동하게 된다. await가 마치 일반 동기 함수가 throw문을 통해 예외를 던지는 것처럼 작동하기 때문이다.

병렬적인 결과 수집에 사용되는 Promise.allSettled 메소드와 잠깐 헷갈렸었다.

| **문법**                 | **목적**                               | **실행 방식**                                                                | **실패 처리**                         |
| ------------------------ | -------------------------------------- | ---------------------------------------------------------------------------- | ------------------------------------- |
| **`async/await`**        | **순차적인** 비동기 코드의 가독성 향상 | **하나씩 기다리며** 위에서 아래로 실행 (동기 코드 형태)                      | `try...catch`로 중앙에서 처리         |
| **`Promise.allSettled`** | **병렬적인** 작업의 모든 결과를 수집   | **동시에 실행**하고 모든 완료를 기다림 (가장 오래 걸리는 작업 시간만큼 소요) | 배열 형태로 모든 결과(성공/실패) 반환 |

## 결론

1. 콜백은 비동기 작업의 결과를 처리하는 가장 기본적인 방법이지만, 콜백 지옥 단점이 있다.
2. 이를 해결하기 위해 작업 상태를 가지고, 순차적인 비동기 작업을 수평적으로 연결한 Promise 객체가 ES6에 등장
3. 프로미스 기반 코드를 동기 코드 형태로 작성할 수 있게하여 직관성을 극대화한 async/await 문법이 ES8에 등장

출처

- [별코딩 비동기 프로그래밍 시리즈](https://www.youtube.com/playlist?list=PLZ5oZ2KmQEYgab5iy6_L8XGMKxhCAN8RV)
- [rohkorea86](https://velog.io/@rohkorea86/Promiseis-%EB%B9%84%EB%8F%99%EA%B8%B0%EB%8F%99%EA%B8%B0%EC%97%90%EC%84%9C-Promise%EA%B9%8C%EC%A7%80#%EC%BD%9C%EB%B0%B1%ED%97%AChell-%ED%94%BC%EB%9D%BC%EB%AF%B8%EB%93%9C-%EB%AC%B4%EB%8D%A4)
