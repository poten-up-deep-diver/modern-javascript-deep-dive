# [JS] 동기와 비동기(feat. Promise/async·await)

## 📝 들어가며

자바스크립트로 개발해오면서 가장 헷갈렸던 개념 중 하나가 바로 동기와 비동기이다. 개발하다가 데이터 값이 담겨야하는데, 출력해보면 프로미스 객체가 담기는 경우도 많았었다.

「모던 자바스크립트 Deep Dive」42장, 45장~46장 스터디를 통해 동기와 비동기 처리에 대해서 깊게 이해해보려고 한다.

## 🤔 동기와 비동기

동기와 비동기의 의미에 대해서 확실하게 알고 가보자.

- 동기 처리: 순차적인 처리 (한 작업이 종료되면 그 다음 작업)
  - 일반적인 모든 코드
- 비동기 처리: 순차적이지 않은 처리(한 작업이 종료되지 않아도 바로 다음 작업 시작)
  - setTimeout, setInterval, HTTP요청, 이벤트 핸들러 등

자바스크립트 엔진은 싱글 스레드 방식으로, 한 번에 하나의 태스크만 처리할 수 있다.

하지만, 비동기 처리를 위해서는 싱글 스레드 방식만으로는 한계가 있어 보인다.

```jsx
setTimeout(() => console.log('a'), 1000);
console.log('b');

// 순서
// b
// a
```

예를 들어, 위의 코드를 살펴보면,

위의 `setTimeout` 함수가 실행이 되고, 1초뒤에 `a`를 출력하는 함수(콜백 함수)를 실행하도록 등록한다.

`setTimeout`은 비동기 처리하므로 바로 다음에 `b`를 출력하고, 약 1초가 지난 후에 `a`를 출력하게 된다.

콜 스택(실행 컨텍스트 스택)에 `setTimeout` 함수가 담기고, 바로 pop되어 스택에서 나오게 될텐데,

어떻게 1초 뒤에 다시 콜 스택에 `a`를 출력하는 함수가 담기는 것일까?

그 답은 바로 이벤트 루프에 있다.

## 🤔 이벤트 루프

이벤트 루프는 자바스크립트 엔진과 별개로, 브라우저에 내장되어 있는 기능이다.

(Node.js에도 이벤트 루프가 있지만, 동작 방식과 구조가 살짝 다르다고 한다.)

이벤트 루프는 쉽게 말해서 브라우저 환경의 관리자이며, 콜 스택, 태스크 큐, 마이크로 태스크 큐를 지속적으로 감시한다.

감시하면서, 콜 스택이 비었을 때, 태스크 큐나 마이크로 태스크 큐에 작업이 있다면 이 작업을 콜 스택으로 푸시해준다.

### 태스크 큐와 마이크로태스크 큐

브라우저 환경에서는 태스크 큐와 마이크로 태스크 큐를 제공해준다.

둘 다 비동기 작업을 위한 대기 공간이라고 할 수 있는데, 담기는 비동기 작업과 우선순위가 다르다.

- 태스크 큐
  - setTimeout, setInterval 등의 비동기 함수의 콜백함수나 이벤트 핸들러가 담긴다.
  - 마이크로 태스크 큐보다 우선순위가 더 낮다
- 마이크로 태스크 큐
  - 프로미스의 후속 처리 메서드의 콜백 함수가 담긴다.
  - 태스크 큐보다 우선순위가 더 높다.

이와 같이 브라우저가 비동기 작업 처리를 위한 환경을 제공해주기 때문에 자바스크립트가 싱글 스레드 방식으로 동작한다고 해도 비동기 작업을 처리할 수 있는 것이다.

## 🤔 프로미스란?

위에서 프로미스의 후속 처리 메서드의 콜백함수는 마이크로 태스크 큐에 담긴다고 했었다.

그렇다면 프로미스란 무엇일까?

자바스크립트는 ES6 이전에서는 비동기 처리를 위해서 콜백 함수를 사용해왔다.

하지만 전통적인 콜백 패턴은 콜백 헬(콜백 안에 콜백이 쌓이는 현상)로 인해 에러 처리 및 한 번의 여러 개의 비동기 작업을 처리하기는 어려웠다고 한다.

이를 개선하기 위해서 ES6에서 비동기 처리를 위한 또 다른 방식으로 프로미스를 도입하게 되었다.

```jsx
// new Promise(callback); callback이 비동기 작업을 하는 함수
// callback === (resolve, reject) => {}
const promise = new Promise((resolve, reject) => {
	// 비동기 처리할 내용 (시간이 걸리는 작업)
	if(/*성공*/){
		resolve(/*비동기 처리 결과*/);
	} else { // 실패
		reject(/*에러 내용*/);
	}
});
```

위의 코드를 살펴보자.

1.  프로미스 생성자 함수를 new 키워드와 함께 호출하면 Promise 객체가 생성된다.
2.  이 때, 비동기 작업을 수행할 콜백 함수를 인수로 전달한다.
3.  콜백 함수의 인수는 resolve, reject로 정해져 있다.
4.  resolve는 성공 시 호출할 함수이며 인수로 비동기 처리 결과를 담는다.
5.  reject는 실패 시 호출할 함수이며 인수로 에러 내용을 담는다.

### 프로미스 객체의 상태

프로미스 객체는 총 3가지 상태를 갖고 있는데, 이는 다음과 같다.

| 상태             | 값        |
| ---------------- | --------- |
| 대기 중(처리 중) | pending   |
| 성공(이행)       | fulfilled |
| 실패(거부)       | rejected  |

프로미스 객체가 생성된 직후부터 pending 상태이며,

비동기 작업이 성공적으로 완료된 경우 fulfilled 상태로 바뀌며,

비동기 작업 중 에러가 발생해서 실패한 경우 rejected 상태로 바뀐다.

```jsx
const promise = new Promise((resolve, reject) => { // 생성 직후부터 pending
	// 비동기 처리할 내용 (시간이 걸리는 작업)
	if(/*성공*/){
		resolve(/*비동기 처리 결과*/); // pending -> fulfilled
	} else { // 실패
		reject(/*에러 내용*/); // pending -> rejected
	}
});
```

다시 코드를 살펴보면

resolve가 실행된 경우 프로미스 객체의 상태가 fulfilled로 바뀌며

reject가 실행된 경우 프로미스 객체의 상태가 rejected로 바뀐다는 의미이다.

그렇다면 객체의 상태가 바뀐다고 해서 무슨 일이 일어나느냐?

아무 일도 일어나지 않는다.

따라서 객체의 상태가 바뀔 때 처리할 내용을 후속 작업으로 작성해주어야 한다.

그것이 바로 `then` , `catch`메서드이다.

### then, catch 메서드

두 메서드 모두 프로미스 객체의 프로토타입 메서드이다.

- `then(callback)`
  - 실행 조건: 프로미스가 fulfilled 상태가 되면 실행됨 (이전 비동기 작업이 완료되면 실행)
  - 콜백 함수의 인자값: `resolve` 함수가 실행될 때 전달한 성공 데이터
  - 반환 값: 새로운 프로미스 객체
- `catch(callback)`
  - 실행 조건: 프로미스가 rejected 상태가 되면 실행됨 (이전 비동기 작업에서 오류 발생 시 실행)
  - 콜백 함수의 인자값: `reject` 함수가 실행될 때 전달한 에러 객체
  - 반환 값: 새로운 프로미스 객체

두 메서드 다 프로미스 객체의 꼬리를 물며 작성이 되는데,

실행 결과로 새로운 프로미스 객체를 반환하기 때문에,

꼬리에 꼬리를 무는 방식인 메서드 체이닝이 가능하다.

다음의 예시를 통해 살펴보자.

```jsx
fetch("http://localhost:3000/posts") // fetch 함수는 프로미스 객체를 반환함
	.then((response) => response.json())
	.then((json) => console.log(json))
	.catch((error) => console.log(error));

console.log("a"); // 해당 줄은 위의 내용을 기다리지 않고 바로 실행됨

// 참고: fetch 함수는 다음과 유사하게 생겼음
const fetch = (url) => {
	return new Promise((resolve, reject) => {
		// url로 요청 작업 (비동기)
		const data = request(url);
		if(/*성공*/){
			resolve(data); // data 값은 다음 then의 콜백함수로 전달됨
		} else { // 실패
			reject(new Error("요청 실패")); // Error는 catch의 콜백함수로 전달됨
		}
	}
}

// 참고: then 메서드는 다음과 유사하게 생겼음
const then = (callback) => {
	return new Promise((resolve, reject) => {
		// 비동기 작업
		const data = callback();
		if(/*성공*/){
			resolve(data); // data값은 다음 then의 콜백함수로 전달됨
		} else { // 실패
			reject(new Error("요청 실패")); // Error는 catch의 콜백함수로 전달됨
		}
	}
}

```

자주 사용해왔던 `fetch` 함수는 사실 프로미스 객체를 반환하는 함수이다.

위의 코드가 성공했을 때와 실패했을 때의 경우를 나눠서 살펴보자.

**요청 성공 시**

1. `fetch` 함수가 실행되면 URL 요청을 시작하고, Promise 객체를 반환함
2. 요청이 성공하면 `resolve(data)`가 실행되어 프로미스는 fulfilled(이행) 상태가 됨.
3. 상태가 fulfilled로 바뀌었으므로, 체이닝된 `then` 메서드의 콜백 함수가 실행됨
4. 이때 `resolve`에 담겼던 `data`가 콜백 함수의 인수(`response`)로 전달됨
5. `response.json()` 역시 비동기 작업이며, 이를 감싸고 있는 `then`은 새로운 프로미스를 반환함
6. `response.json()`이 완료되면 다시 `resolve`가 실행되고, 다음 `then`으로 결과(`json`)가 전달됨
7. 이 과정이 반복되면서 비동기 작업을 순차적으로 처리할 수 있음

**요청 실패 시**

1. `fetch` 실행 후 요청이 실패하면 `reject(Error)`가 실행되어 rejected(거부) 상태가 됨
2. 상태가 rejected로 바뀌었으므로, 체이닝된 `catch` 메서드의 콜백 함수가 실행됨
3. 이때 `reject`에 담겼던 `Error` 객체가 콜백 함수의 인수(`error`)로 전달됨
4. 이를 통해 비동기 작업 중 발생한 에러를 체크할 수 있음

함수와 메서드가 프로미스 객체를 반환하고,

성공 시 데이터가 resolve에 담기고,

다음 then의 콜백함수의 인수로 들어가는 흐름이 참 복잡하지 않은가?

이를 더욱 가독성 있게 표현하기 위해서 등장한 것이 바로 async와 await이다.

## 🤔 async와 await

async와 await는 ES8에 도입된 키워드로,

이를 사용하면 then, catch 메서드 체이닝을 통해 작성할 필요 없이,

동기 처리처럼 프로미스를 사용할 수 있다.

위에서 작성한 코드를 async와 await를 통해 다시 작성해보자.

```jsx
async function getData() {
  const response = await fetch(url); // 끝날 때까지 일시 중지
  const json = await response.json(); // 끝날 때까지 일시 중지
  console.log(json);
  return json;
}
```

await 키워드는 async 함수 내에서만 작성할 수 있으며, 주로 프로미스 객체 앞에 붙인다.

이 때, 해당 프로미스가 처리될 때까지 실행을 잠시 일시 중지하며,

성공 시 `resolve` 에 담긴 값이 반환된다. (프로미스 객체를 반환하지 않는다.)

따라서 위와 같이 변수에 할당해서 사용할 수 있는 것이다.

그렇다면 에러를 체크하는 부분은 어떻게 구현할 수 있을까?

```jsx
async function getData() {
  try {
    const response = await fetch(url);
    const json = await response.json();
    console.log(json);
    return json;
  } catch (error) {
    console.log(error);
  }
}

getData();
```

다음과 같이 try catch 문으로 묶어서 에러를 체크할 수 있다.

## 🧑🏻‍⚖️ 결론

1. 자바스크립트는 싱글 스레드 언어지만, 브라우저의 이벤트 루프를 통해 비동기 처리가 가능하다.
2. ES6에서 프로미스가 도입되어 기존 콜백 패턴의 복잡성을 효과적으로 해결했다.
3. ES8에 도입된 async/await 문법을 사용하면 비동기 흐름을 동기 코드처럼 직관적으로 작성할 수 있다.
