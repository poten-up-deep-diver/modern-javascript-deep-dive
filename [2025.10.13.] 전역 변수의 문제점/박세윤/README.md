# JavaScript의 모듈 시스템(CJS, ESM)

## ✋🏻 들어가기 전

「모던 자바스크립트 Deep Dive」13장~15장을 읽으며, 스코프에 대한 개념에 대해서 공부해보았다.

브라우저에서는 원래 Classic JavaScript 기반으로, 최상위 스코프에서 변수를 선언하면 전역 변수로 선언되며, window 객체의 프로퍼티로 사용된다는 것을 알 수 있었다.

하지만, ES6의 모듈을 사용하면 파일 자체의 독자적인 모듈 스코프를 제공하므로, 더 이상 전역 변수를 사용할 수 없다고 한다.

이 점을 좀 더 깊게 알아보고, 더 나아가 CJS와 ESM에 대해서 알아보고자 한다.

## 🤔 브라우저와 Node.js

우선 전역 변수를 사용할 수 있는 Classic JavaScript와 전역 변수를 사용할 수 없는 CJS(Common JS), ESM(ECMAScript Modules)에 대해 알기 위해선, **브라우저와 Node.js의 차이**를 인지해야 한다.

**JavaScript** 언어는 초기에 **웹 브라우저에서만 작동**하는 프로그래밍 언어였으며, **Node.js**는 클라이언트 쪽 뿐만 아니라, 서버 쪽에도 JavaScript를 사용하기 위해서 구글의 **V8엔진을 기반**으로 만든 **런타임 환경**이다.

Node.js가 출시되고 웹 애플리케이션의 규모가 커지면서, 수많은 스크립트 파일들이 전역 변수를 통해 관리되는 방식의 한계에 부딪혔다.

이 한계를 극복하기 위해 모듈 시스템의 필요성이 대두되었는데, 이 때 만들어진 **모듈 시스템**이 바로 **CJS(CommonJS)**이다. Node.js는 이 CJS를 채택해서 사용해왔다.

## 🤔 브라우저와 CJS의 연관성

그렇다면 CJS는 서버 사이드에서 사용되는 모듈 시스템이라고 할 수 있는데, 브라우저와는 전혀 무관한 내용일까?

결론부터 말하자면, 아니다.

Node.js 환경에서 사용되는 모듈 시스템은 편리했기 때문에, 브라우저에서도 사용하고자 하였다. 하지만 **브라우저는** **CJS를 직접 지원하지 않기 때문**에, CJS방식으로 작성된 파일을 이해할 수 없었으므로, Webpack 등의 모듈 번들러를 활용하여 번들링해서 사용하였다.

※ **모듈 번들러**: 간단하게 말하자면, 여러 모듈(파일)들을 하나의 자바스크립트 파일로 합쳐주는 도구이다. CJS로 작성된 파일들을 모듈 번들러를 통해 하나로 합치고, 이 합친 파일을 `<script>` 태그로 불러와서 사용한다.

## 🤔 CJS의 한계와 ESM의 등장

이렇게 잘 사용하고 있던 CJS에도 명확한 한계를 가지고 있었는데, 이는 다음과 같다.

1. **동기적 실행 - UI 렌더링 차단**

   CJS에서는 `require()`을 통해 다른 모듈 파일을 읽어들일 수 있는데, 이 구문이 동기적으로 실행된다. 브라우저에서 `require()` 를 그대로 도입한다면 다른 모듈을 모두 읽어들일 때 까지 UI 렌더링이 차단되는 현상이 발생한다.

2. **동적인 구조 - 최적화 적용 어려움**

   CJS에서 `require()`는 일반 함수이므로, 조건문 안에서 호출하는 등의 동적 호출이 가능하다. 하지만 이러한 경우 코드를 실행하기 전까지 모듈 간의 의존성 구조를 파악할 수 없으므로, 최적화 기법을 적용하기 어렵다.

이러한 CJS의 한계를 극복하고, 브라우저와 서버를 아우르는 하나의 공식 표준 모듈 시스템을 만들기 위해서 자바스크립트 표준 사양으로 ES 모듈(ESM)이 설계되었다. 이러한 ESM은 CJS와 반대되는 다음의 특징을 가진다.

1. **비동기적 로드 - 브라우저 환경에 부합**

   ESM은 코드를 실행하기 전, `import`문을 통해서 전체 모듈의 의존성 트리를 먼저 구성한다. 그리고, 필요한 모든 모듈 파일들을 비동기적으로 다운로드하고 모든 준비가 끝나면 그 때 코드를 실행한다. 따라서 웹 환경에 더욱 적합하다.

2. **정적인 구조 - 최적화에 유리**

   `import`와 `export`는 함수가 아닌 특별한 키워드 이므로 모듈의 최상위 레벨에서 사용되어야 하며, 동적 호출이 불가능하다. 따라서 코드를 실행하지 않고도 모듈 간의 의존성을 파악하여 사용하지 않는 모듈을 알 수 있으므로, 최적화에 훨씬 유리하다.

책의 예시와 같이, ESM은 자바스크립트 표준이므로 현대 브라우저에서는 이를 번들링할 필요 없이 다음과 같이 `type="module"`속성을 추가하여 ESM 파일을 직접 로드하고 파싱할 수 있다.

```html
<script type="module" src="app.js"></script>
```

※ ESM이 브라우저에서 직접 지원되더라도, 성능 최적화 및 구형 브라우저 호환성 등의 이유로 여전히 모듈 번들러는 사용된다.

※ Node.js는 오랜 기간 동안 CJS을 기반으로 생태계가 구축되었기 때문에 아직도 CJS를 사용하는 패키지나 프로젝트가 많다고 한다. 따라서 점진적으로 ESM으로 전환하거나 도입하고 있다고 한다.

## 🧑🏻‍⚖️ 결론

1. Node.js는 브라우저에서만 돌아가던 JavaScript를 서버 측에서 사용하기 위해서 만들어진 런타임 환경임
2. CommonJS의 등장으로 전역 변수 오염을 막을 수 있었음
3. CJS의 한계를 극복하기 위한 ESM의 등장으로 자바스크립트 생태계가 표준화됨
