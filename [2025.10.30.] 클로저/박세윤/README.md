# [JS] 클로저의 원리와 활용

## 🤚🏻 들어가기 전

「모던 자바스크립트 Deep Dive」24장을 읽고, 드디어 그 난해하다는 **“클로저”**에 대해 알아볼 수 있었다.

책을 읽기 전 까지는 클로저에 대해 무지했고, 개념을 알아보려고 해도 무슨 말인지 명확하게 이해할 수 없었는데, 23장 전까지의 책의 내용에서 빌드업이 쌓인 탓인지 클로저에 대한 개념이 확 와 닿은 순간이었던 것 같다.

하지만 실제로 “내가 코드를 작성할 때 도대체 어디서 활용할 수 있을까?”에 대한 의문은 남아있어서 이에 대해 더 정리해보고자 한다.

## 🤔 클로저란?

실질적으로, 클로저가 되기 위해선 다음과 같은 조건에 충족해야 한다.

1. **외부 함수 내에 작성된 중첩(내부) 함수**
2. **상위 스코프의 식별자를 참조**
3. **외부 함수보다 더 오래 생존**

아래는 간단한 클로저의 예시이다.

```jsx
function outer() {
  var a = 10;
  function inner() {
    console.log(a);
  }
  return inner;
}

var print = outer();
print(); // 10 출력
```

위의 코드에서 `inner()` 함수가 클로저라고 할 수 있는데, 조건을 하나씩 살펴보자.

먼저, 외부 함수 `outer()` 함수 내에 `inner()` 함수가 작성되었기 때문에 1번 조건을 충족한다.

그리고, `inner()` 함수는 상위 스코프의 식별자 `a`를 참조하고 있기 때문에 2번 조건을 충족한다.

마지막으로, `outer()` 를 호출하여, 반환된 `inner` 함수를 `print` 식별자로 참조하고 있기 때문에, `outer()` 함수의 실행이 종료되더라도, `inner` 함수는 계속 살아있다. 따라서 3번 조건도 충족한다.

따라서 위 코드의 `inner()` 함수는 클로저라고 할 수 있는 것이다.

## 🤔 사라진 변수를 참조?

위의 예시 코드와 같이, `print()` 함수를 실행하면 10을 출력하는 것을 확인할 수 있다.

하지만, `outer()` 함수가 종료되면, 해당 함수의 실행 컨텍스트가 사라질텐데, 어떻게 outer 함수 렉시컬 환경의 `a` 값을 가져올 수 있을까?

### 가비지 컬렉션

질문의 해답을 찾기 위해서는, 가비지 컬렉션이라는 개념을 이해해야 한다.

Javascript에서는 값을 선언할 때, 자동으로 메모리를 할당하고, 할당된 메모리가 필요 없을 때 메모리에서 해제한다.~~(없애버린다)~~

즉, Javascript의 메모리 할당과 메모리 해제는 개발자가 직접 하는게 아니라, **가비지 컬렉션이 자동으로 판단하고 관리**한다.

이 때, 판단 기준은 **“참조”**이다.

말 그대로, 참조되는 값은 필요하고, 참조되지 않는 값은 필요하지 않다고 판단하는 것이다.

### 렉시컬 환경은 사라지지 않는다

위에서 언급했듯이, 참조되지 않은 값은 가비지 컬렉션이 메모리에서 삭제한다.

outer의 실행 컨텍스트는 함수 실행이 종료되면 스택에서 pop되어 없어지지만, outer의 렉시컬 환경은 상황이 조금 다르다. 예시를 다시 살펴보자.

```jsx
function outer() {
  var a = 10;
  function inner() {
    console.log(a);
  }
  return inner;
}

var print = outer();
print(); // 10 출력
```

위의 예시가 어떤 순서로 실행 컨텍스트가 만들어지는지 다이어그램을 통해 확인해보자.

![](https://velog.velcdn.com/images/seyun0714/post/de995b9c-445e-4d36-8b0e-422a6fd51f2e/image.png)

1. 위의 상황이 위의 전역 코드를 실행하기 전에 생성이 되는 부분이다. 이 때 중요한 부분은, `outer` 함수가 평가되어, outer 객체가 생성될 때, `[[environment]]` 내부 슬롯에 자신의 상위 스코프(렉시컬 환경)가 어딘지 써놓는다.

![](https://velog.velcdn.com/images/seyun0714/post/57e95fca-28f4-424a-8406-2a060055f1dd/image.png)

2. 이 후, `var print = outer()` 코드가 실행되어, `outer()` 함수가 호출되면 다음과 같이 만들어진다. 중요한 부분은 `outer` 렉시컬 환경이 만들어질 때 아까 `[[environment]]` 자리에 써놓은 상위 스코프를 보고 연결한다. 결과적으로, `outer` 렉시컬 환경은 전역 렉시컬 환경에 연결된다.

3. 1번과 동일하게, outer 함수가 실행 되기 전에 내부의 `inner` 함수가 평가되어 `inner` 객체가 생성될 때, `[[environment]]` 자리에 자신의 상위 스코프(렉시컬 환경)가 어딘지 써놓는다.

그리고 다음 과정에서 놀라운 일이 일어난다.

![](https://velog.velcdn.com/images/seyun0714/post/8078843f-9ac4-46be-a4b1-0496b6852bde/image.png)

4. `var print = outer()` 코드가 모두 실행되고 난 뒤의 결과이다. `outer` 함수는 종료되어 `outer`실행 컨텍스트는 사라졌지만, 렉시컬 환경은 남아있는 것을 확인할 수 있다. 도대체 왤까?
5. `outer`는 `inner`를 반환하고 종료된다. 반환할 때, inner 함수 객체를 전달하는 것이다. 따라서 `print` 식별자에, inner 함수 객체의 참조가 전달된다.
6. 아까 말했듯이, 가비지 컬렉션은 참조되는 값이면 삭제하지 않는다. `print` 는 inner 함수 객체를 참조하고, `[[environment]]` 내부 슬롯이 outer 렉시컬 환경을 참조하므로, outer의 렉시컬 환경은 사라지지 않고 남아있다.

![](https://velog.velcdn.com/images/seyun0714/post/ee948125-1c3f-4c44-81fb-f7e5771ad425/image.png)

7. `print()` 실행 순서가되면, `print` 식별자에 할당된 `inner` 함수가 호출 된다. 2번 과정과 동일하게, inner 렉시컬 환경이 만들어질 때, inner 함수 객체 안에 써놓은 `[[environment]]` 을 보고, 상위 스코프를 연결한다. 따라서 다음과 같이 연결된다.
8. `console.log(a)` 가 실행될 때, 식별자 `a` 를 inner 환경 레코드 안에서 먼저 찾지만 a가 없기 때문에, 상위 스코프인 outer 렉시컬 환경으로 올라가서 찾는다. 이러한 방식으로 `a` 를 참조할 수 있는 것이다

## 🤔 클로저의 활용?

자 이렇게 클로저인 inner가 outer의 `a`를 참조하는 예시를 살펴보았다.

그렇다면, 클로저를 어디서 활용할 수 있을까?

책의 내용에서는 다음과 같이 설명한다.

> 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

위의 설명이 추상적이기 때문에 명확하게 느낌이 오지 않는다. `setInterval()`을 활용한 예시를 보면서 살펴보자.

```jsx
const [timer, setTimer] = useState(0);
const [status, setStatus] = useState(false);

// 설정 함수
useEffect(() => {
  let intervalID;
  if (status) {
    intervalID = setInterval(() => {
      setTimer((prev) => prev + 1);
    }, 1000);
  }

  // 정리 함수 - 클로저
  return () => {
    clearInterval(intervalID);
  };
}, [status]);

// ----------------------------------------------
// 설정 함수를 풀어서 써보면 다음과 같다.
function setup() {
  let intervalID;
  if (status) {
    intervalID = setInterval(/* ... */);
  }

  // 정리 함수
  function cleanup() {
    clearInterval(intervalID);
  }

  return cleanup;
}
```

해당 예시에서는, useEffect로 실행되는 설정 함수 내에서 `setInterval`를 통해 `timer` 값을 1초 마다 1씩 증가시키고 있다.

또한, 설정 함수의 반환 값으로 정리 함수를 반환하고 있다.

설정 함수 내부에 정리 함수가 작성되어 있고, 정리 함수는 해당 컴포넌트가 업데이트 되거나, 컴포넌트가 언마운트될 때 실행되므로 설정 함수보다 오래 살아남는다고 볼 수 있다.

또한 정리 함수가 설정 함수의 변수인 `intervalID` 변수를 참조하고 있다.

결과적으로, 설정 함수 내에서 정의한 `intervalID` 값을 가지고, 나중에 이를 참조하여 `clearInterval` 하고 싶은 경우에, 이런 식으로 클로저를 활용하여 구현할 수 있다.

또한, `intervalID`를 임의로 수정할 수 있다면 `clearInterval`이 정상적으로 동작하지 않을 수 있는데, 이렇게 클로저를 활용하게 되면, 해당 `intervalID`를 참조할 수 있는 것은 정리 함수밖에 남지 않는다.

따라서 이렇게 `intervalID`를 캡슐화하여 안전하게 사용할 수 있는 것이다!

## 🧑🏻‍⚖️ 결론

1. 클로저는 자신이 생성된 환경을 기억하여, 실행이 끝난 외부 함수의 변수에도 계속 접근할 수 있는 함수임
2. 이러한 특성 때문에 특정 상태(데이터)를 외부로부터 안전하게 숨기는 **캡슐화**가 가능함
3. 결과적으로 클로저는 상태가 의도치 않게 변경되는 것을 막고, 허용된 함수로만 제어하기 위한 핵심 패턴으로 활용됨
