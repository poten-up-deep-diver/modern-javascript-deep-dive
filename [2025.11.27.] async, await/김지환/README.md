# 동동, 프미

# 🤨 비동기와 동기

## 🤨 동기(Synchronous) 처리

- **작동 방식**:
  - 함수가 호출되면 실행 컨텍스트가 스택에 푸시 → 실행 → 종료 시 팝
  - 한 번에 하나의 함수만 실행 가능 (싱글 스레드)
  - 이전 작업이 끝나야 다음 작업 실행한다.
- **장점**: 실행 순서 보장한다.
- **단점**: 오래 걸리는 작업이 있으면 블로킹 발생한다.

### 예시

```jsx
sleep(foo, 3000);
bar(); // 3초 이상 대기 후 실행
```

- `sleep`이 끝날 때까지 `bar()` 실행 불가 → 블로킹 발생

---

## 🤨 비동기(Asynchronous) 처리

- **작동 방식**:
  - 현재 작업이 끝나지 않아도 다음 작업을 바로 실행된다.
  - 콜백 함수는 나중에 적절한 시점에 실행된다.
- **장점**: 블로킹 없다.
- **단점**: 실행 순서 보장 어렵다.

### 예시

```jsx
setTimeout(foo, 3000);
bar(); // 즉시 실행됨
```

- 3초 후 `foo()` 실행한다.
- `bar()`는 블로킹 없이 바로 실행한다.

## 🤨 동기 vs 비동기 비교

| 구분      | 동기 처리             | 비동기 처리                                |
| --------- | --------------------- | ------------------------------------------ |
| 실행 순서 | 보장됨                | 보장 안 됨                                 |
| 블로킹    | 발생                  | 없음                                       |
| 구조      | 단순                  | 복잡                                       |
| 예        | 직접 연산, sleep 구현 | setTimeout, setInterval, 이벤트, HTTP 요청 |

# 🤨**동기(Synchronous) 언제 쓰는가?**

- 코드 실행 순서가 중요할 때, 앞 작업이 끝나야 다음 작업을 할 수 있을 때

# 🤨**비동기(Asynchronous) 언제 쓰는가?**

- 시간이 오래 걸리는 작업을 처리할 때, 기다리는 동안 다른 작업도 해야 할 때

# 😒프로미스

## 🤨 프로미스란

프로미스는 비동기 작업의 결과를 표현하는 약속 객체다.

지금은 모르지만, 나중에 성공하거나 실패한 값을 담아서 알려줄게 라고 약속하는 개념이다.

## 🤨 **프로미스 체이닝이 뭘까?**

프로미스는 비동기 작업 결과를 다루는 객체고,

**체이닝**은 → 이전 작업이 끝나야 다음 작업이 실행되도록 연결하는 방식이야.

즉,

“A가 끝나면 B, B가 끝나면 C 를 하겠다” 를 코드로 표현하는 것!

## **😂프로미스 장점**

### **1. 비동기 흐름을 깔끔하게 관리**

- 콜백 지옥(callback hell)을 해결해 코드 가독성이 좋아진다.

### **2. 에러 처리 일원화**

- `.catch()` 하나로 비동기 에러를 통합적으로 처리할 수 있다.

## **😂**프로미스 단점

### **1. then 체이닝이 길어지면 여전히 복잡**

- async/await에 비해 코드가 길고 들여쓰기 많아진다.

### **2. 디버깅이 불편함**

- 비동기 흐름 때문에 실행 순서를 따라가기 어렵고 스택 추적이 복잡하다.

# 💯결론

1. 프로미스는 비동기 작업을 깔끔하게 관리하지만, 체이닝이 길면 복잡하고 디버깅이 어렵다.
2. 동기는 순서 보장하지만 블로킹 발생, 비동기는 블로킹 없지만 실행 순서가 보장되지 않는다.
