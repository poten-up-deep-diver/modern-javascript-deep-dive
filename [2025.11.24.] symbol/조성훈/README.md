## 들어가기 전

개발학원에 들어온지 2개월이 지났다. JS의 데이터 타입을 공부할 때, string, number, boolean, undefinedm null 같은 기본 데이터 타입과 객체 타입을 이해하고, falsy값들까지 정리할 수 있었다.

하지만 프로젝트나 예제 코드에서 흔히 접하지 못한 데이터 타입이 있었으니. 바로 ES6에서 등장한 7번째 타입 심볼이다. 어떤 배경에서 등장했고, 어떤 장점을 가지고 있는지 자세히 알아보자.

## 유일무이한 값 (고유성)

사실, 변수에 새로운 값을 할당하지 못하는 const 키워드랑 헷갈렸다. (엣쿵)

| **특징**            | **const**                                                   | **Symbol**                                                                  |
| ------------------- | ----------------------------------------------------------- | --------------------------------------------------------------------------- |
| **적용 대상**       | **변수(Variable)**                                          | **데이터 타입(Data Type)**                                                  |
| **의미하는 불변성** | 변수에 **재할당** 금지 (메모리 주소 변경 금지)              | 데이터 **값 자체**가 생성 후 변경 불가능 (고유성)                           |
| **예시**            | `const x = 10;` $\rightarrow$ `x`에 다른 값을 넣을 수 없음. | `Symbol('id')` $\rightarrow$ 이 값 자체가 유일하고 변경되지 않는 고유한 값. |

const는 이 변수에 다른 값을 넣지 마세요! 라는 선언이고, Symbol은 이 값은 세상에서 나 하나밖에 없어! 라는 데이터 자체의 특성이다.

따라서 Symbol은 이름 충돌 위험이 있는 객체의 키를 만들기 위해 사용된다. 이러한 고유성 덕분에, 외부 라이브러리나 다른 사람이 만든 객체에 우리가 필요한 새로운 속성을 안전하게 추가할 때 사용된다. 기존 속성을 실수로 덮어쓸 염려가 전혀 없기 때문.

### Symbol 함수

그렇다면 `Symbol()`가 생성자 함수가 아닌 팩토리 함수로 작동하며 매번 새로운 고유한 값을 반환하는 핵심 동작은 어떤 원리로 이루어지는 걸까?

- 생성자 함수: `new` 키워드를 사용하여 새로운 인스턴스 생성
- 팩토리 함수: 일반 함수처럼 return {} 명시적 객체를 생성

Symbol('id') 함수를 호출할 때마다 고유한 값이 생성되지만 이때 전달하는 문자열 "id"는 설명일 뿐 값의 유일성에 영향을 주지는 않는다. 마치 자동으로 문서의 id 값을 생성하는 것처럼, 이전에 존재하지 않았던 새로운 숫자가 부여되어 고유성이 보장되는 것이다.

여기서 id는 Symbol 값 자체에 아무런 영향을 미치지 않으며, 콘솔 출력 등 디버깅 상황에서 개발자 가독성을 높이기 위해 존재하는 것이다. 마치 포토샵의 레이어 이름이 겹치더라도, 레이어 자체의 고유한 Symbol 값은 변하지 않는 것처럼, 디자이너가 레이어 이름을 보고 어떤 역할을 하는지 돕는 것과 마찬가지다..!

Symbol.for('id')를 통해 같은 id를 사용하면 같은 값 반환할 수도 있다. 이 둘의 차이점이 인상깊다.

## 프라이빗한 속성 (은닉성)

Symbol 데이터 타입이 객체의 속성으로 사용될 때, for in 루프나 Object.keys() 와 같은 메서드로는 접근할 수 없다. Symbol은 고유한 특성을 넘어, 은닉성도 가지고 있다.

그렇다면 왜 그렇게 만들어졌을까? ES6에서 등장했을 때, 기존 JavaScript 객체의 단점을 보완하기 위해 만들어졌다. 그 단점은 바로 "객체 속성이 너무 쉽게 노출되고 충돌된다" 였다.

- `for...in` 루프
- `Object.keys(obj)`
- `Object.getOwnPropertyNames(obj)`
  를 통해 객체의 속성을 순회할 수 있다. 이 메서드들은 일반적인 문자열 키만을 대상으로 작동하도록 설계되어 있다. (enumerable 속성이 true인 문자열 키)

Symbol키는 의도적으로 이 목록에서 제외되고, 라이브러리나 프레임워크가 객체에 내부적으로 필요한 속성을 추가할 때, 사용자가 실수로 그것을 건드리거나 목록에서 보지 못하게 하기 위함이다.

ES6의 class 문법처럼 enumerable 속성 여부를 강제로 정해주는 흐름과 관계없이 Symbol키는 생성 시점에 객체의 일반적인 순회 매커니즘에서 분리되어 있다.

JS 객체는 내부적으로 속성을 문자열 키를 가진 속성과 Symbol키를 가진 속성을 분리하여 저장한다. 객체 내부 슬롯에 별도로 관리되는 Symbol 전용 목록이 있으며, 이에 접근할 수 있는 메서드가 따로 존재한다는 것이다!

`Object.getOwnPropertySymbols(obj)` 메서드를 통해 Symbol키를 따로 모아서 볼 수 있기에 완전히 접근이 불가능한 것은 아니다. 하지만, 이러한 특별한 접근 방식이 따로 존재한다는 것은, Symbol이 일반적인 속성과는 다르게 숨겨진 목적으로 사용되기 때문이라는 점이 중요하다.

### enumerable과 차이점?

개발자가 속성의 enumerable 여부를 직접 true 또는 false로 지정할 수 있는데, 왜 굳이 Symbol이라는 새로운 타입을 사용해서 숨겨야 하는지가 궁금해졌다. 찾아보니, JS 생태계와 라이브러리 설계라는 더 넓은 맥락에 정확한 차이가 있었다.

> Symbol을 사용하는 가장 큰 주체는 객체를 사용하는 사람이 아니라, 객체를 만드는 사람

Symbol은 속성 이름 자체가 고유하기 때문에, 라이브러리나 프레임워크가 어떤 객체에 내부적인 기능을 추가할 때, 사용자가 원래 객체에 추가하려는 속성 이름과 겹칠 염려가 완전~ 없어진다.

### 라이브러리에 내부 속성 추가

객체를 만든 사람이 A라는 라이브러리 제작자이고, 객체를 사용하는 사람이 B라는 애플리케이션 개발자라고 가정해보자.

A (라이브러리 제작자)는 B에게 넘겨준 객체에 내부 상태를 관리하는 속성을 몰래 추가하고 싶다.

- 문자열 키 사용 시: `'status'`라는 키를 쓰면, B가 나중에 자신의 코드에서 `'status'`를 정의할까 봐 걱정.
- `Symbol` 키 사용 시: `const statusSymbol = Symbol('library.status');`로 키를 만들고 값을 저장하면, B가 어떤 문자열 키를 쓰든 이 키는 절대 겹치지 않는다

Symbol은 숨기는 기능(은닉성)을 넘어, 객체를 충돌 없이 안전하게 확장할 수 있는(고유성) 자리를 제공하는 것에 가치가 있다.

## 결론

**문제:** 객체 속성의 이름이 충돌하거나, 내부 데이터를 은닉해야 한다
**솔루션:** 자동적으로 유일무이한 값을 만들어주는 Symbol() 함수
**특징:**

1. 고유성: 키 이름이 절대 중복되지 않는다.
2. 은닉성: 일반적 순회 메서드에서 제외된다.
