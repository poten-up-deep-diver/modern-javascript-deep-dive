# 클로저와 함수 객체 안의 내부 슬롯Environment

### 😒클로저란 무엇인가

`클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.
정의가`

**클로저는** 함수가 선언될 때의 **주변 환경을 기억해** 그 함수가 나중에 다른 곳에서

실행되더라도 당시의 **변수나 값에 계속 접근할 수** 있게 해주는 기능이다.

### 클로저의 조건(3가지)

1. **함수 안에 또 다른 함수가 정의되어 있을 것 (중첩 함수)**
2. **내부 함수가 외부 함수의 변수를 사용하고 있을 것**
3. **내부 함수가 외부 함수보다 더 오래 살아있을 것 (외부 함수가 종료된 뒤에도 실행됨)**

## 😒클로저 예시

### 클로저 예시

```jsx
const x = 1;

function outer() {
  const x = 10;
  function inner() {
    console.log(x);
  }
  return inner;
}

const func = outer();

func(); // ?
```

---

### 💬 설명

`func`는 `outer`가 끝난 뒤에도 `outer` 안의 변수 `x = 10`을 기억하고 있어서,
`func()`를 실행하면 `10`이 출력됨
이런 현상을 **클로저(closure)**라고 합니다.

## 렉시컬 스코프란

**렉시컬 스코프(Lexical Scope)**란 함수가 **어디서 선언되었는지**

를 기준으로 변수의 유효 범위(스코프)가 결정되는 방식이다.

## 렉시컬 스코프 설명

### 코드 예시

```jsx
const x = 1; // 전역

function outer() {
  const x = 10; // outer 스코프

  function inner() {
    console.log(x); // inner가 선언된 위치 기준
  }

  return inner;
}

const func = outer();
func(); // 10
```

- `inner` 함수는 `outer` 안에서 선언됐기 때문에 **outer 스코프의 x**를 기억한다.
- 호출 위치가 어디든(`func()`), **선언된 위치 기준**으로 변수 참조
- **이것이 렉시컬 스코프의 핵심 원리이다.**

## 😒클로저를 쓰는이유

- **데이터 은닉** – 외부에서 직접 접근 못하게 보호함
- **상태 유지** – 함수가 실행된 후에도 변수 값이 계속 남음
- **캡슐화** – 관련된 데이터와 기능을 묶어서 관리 가능
- **콜백·이벤트 처리에 유용** – 실행 시점이 달라도 변수 기억 가능

## 💯 결론

**클로저** = **“클로저는 함수가 만들어질 때의 변수를 기억해서, 나중에 함수가 호출될 때도**

**그 변수에 접근할 수 있는 함수”**

**렉시컬 스코프 = “함수가 선언된 위치를 기준으로 변수 접근 범위가 결정되는 규칙”**
