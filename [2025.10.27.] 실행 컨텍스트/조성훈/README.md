# 실행 컨텍스트

## (복습) var 키워드, 호이스팅, 스코프, this 바인딩

**호이스팅**
var 키워드로 선언된 변수 식별자를 미리 등록하고, undefined로 초기화한다.
함수 선언문의 경우 선언문 전체가 렉시컬 환경에 등록되고 즉시 함수 객체로 초기화된다.

**this 바인딩**
함수가 호출되는 방식에 따라, this 키워드가 바라볼 객체를 결정한다.

**스코프**
스코프는 변수에 접근할 수 있는 범위이며, 함수가 실행될 때 각 스코프에 해당하는 실행 컨텍스트가 콜 스택에 쌓인다.

## 실행 컨텍스트는? (포토샵 비유)

```
실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.
식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다.
```

자바스크립트 엔진은 소스코드를 평가하고 실행하는 두 단계를 거친다. 실행 컨텍스트는 그 과정 자체를 일컫는 개념이 아니라 이 두 단계를 거치면서 코드가 성공적으로 실행되도록, 필요한 환경 정보를 모아 놓은 일종의 청사진이다.

나는 시각디자인 전공을 했기에, 어도비 소프트웨어에 비유하여 context(맥락)을 이해하는 것을 좋아한다.

자바스크립트 엔진이 코드를 실행하는 것은 마치 포토샵으로 내 증명사진을 편집하는 것과 같다. 실행 컨텍스트 스택은 책상 위에 쌓인 작업 파일 더미라고 상상해보자.

1. 전역 코드 평가
   새 포토샵 파일 생성 및 이미지 크기와 같이 초기 설정:
   호이스팅 발생! 파일이 열리자마자 전역 layer 이름과 이미지 크기가 등록된다.

2. 전역 코드 실행
   프로젝트 메인 작업 시작:
   등록된 레이어, 이미지에 실제 픽셀 값을 채워 넣고, 얼굴을 더블 클릭하여 이목구비를 수정(함수호출) 하려 한다.

3. 함수 호출 및 함수 코드 평가
   메인 작업 (전역 컨텍스트)를 일시 중단하고, 얼굴 편집이라는 새로운 작업 환경을 책상 위에 새로 쌓는다. 이때 얼굴 내부의 지역 변수 (let, const) 들이 환경에 등록됨.
   눈썹, 눈동자 크기, 코 크기, 입술 등...

4. 함수 코드 실행 및 식별자 검색
   얼굴 편집 작업 진행: 얼굴 내부에서 눈동자 색을 찾아 칠하려 한다. 먼저 현재 얼굴에서 어울리는 색상을 찾고, 없으면 상위 레이어로 올라가 찾는다. (스코프 체인)

5. 함수 종료 및 복귀
   얼굴 편집 완료 및 복귀:
   얼굴 편집을 끝내면 해당 작업 파일을 책상에서 치우고, 이전에 중단했던 메인 프로젝트 파일로 돌아와 작업을 재개한다.

6. 전역 코드 종료
   프로젝트 파일 저장 및 닫기: 모든 코드가 끝나면, 마지막으로 남아있던 메인 프로젝트 파일도 제거된다.

## 실행 컨텍스트의 역할

1. 식별자(변수, 함수) 및 상태 관리
   각 작업 파일이 그 안의 레이어와 색상 목록을 독립적으로 관리하고 있다.
   실행 컨텍스트의 렉시컬 환경(Lexical Environment)가 이 역할을 담당.

2. 스코프 체인을 통한 식별자 검색
   현재 레이어에서 원하는 색상을 못 찾으면 상위 레이어로 이동해 찾는 과정.
   렉시컬 환경의 외부 렉시컬 환경에 대한 참조가 이 연결고리를 만든다.

3. 코드 실행 순서 변경 및 복귀
   얼굴 편집 모드로 들어갔다가 push, 작업 완료 후 원래 자리로 돌아오는 pop 과정
   실행 컨텍스트 스택이 이 순서를 후입선출 Last In First Out 원리로 관리한다.

## 렉시컬 환경

전역 실행 컨텍스트의 렉시컬 환경은 var 과 let/const 변수를 다르게 관리하기 위해 내부적으로 두 개의 환경 레코드를 가진다.

1. 객체 환경 레코드 Object Environment Record
   var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수::
   이 레코드는 전역 객체를 바인딩 객체로 참조함. 여기에 등록된 모든 식별자는 자동으로 전역 객체의 프로퍼티가 되는 것!
   결과: var x = 1;을 선언하면, window.x로 접근할 수 있다.

2. 선언적 환경 레코드 Declaration Environment Record
   let, const 키워드로 선언된 전역 변수 및 함수 표현식
   이 레코드는 전역 객체와 직접 연결되지 않고 돌깁적으로 존재하며 변수 식별자를 관리함.
   결과: const y = 2;를 선언해도, 이 변수는 오직 이 선언적 환경 레코드 내에서만 관리되며, window.y로는 접근할 수 없다.

## 스코프 체인

스코프 체인은 위 렉시컬 환경들이 서로 연결되어 변수를 탐색하는 방법이다.
스코프 체인은 자바스크립트 인젠이 특정 변수(식별자)의 값을 찾을 때, 자신이 속한 스코프부터 상위 스코프까지 차례로 거슬러 올라가며 검색하는 논리적 연결고리이다.

**Outer Lexical Environment Reference**
실행 컨텍스트의 렉시컬 환경 내부에 있는 "외부 렉시컬 환경에 대한 참조" 컴포넌트로 구현된다

함수가 호출되어 함수 실행 컨텍스트가 생성되면, 자바스크립트 엔진은 먼저 현재 컨텍스트의 렉시컬 환경에서 필요한 변수를 찾는다. 만약, 현재 렉시컬 환경에 찾는 변수가 없다면, 엔진은 해당 렉시컬 환경의 **Outer Lexical Environment Reference**가 가리키는 바로 한 단계 상위 스코프의 렉시컬 환경으로 이동한다.
**이 외부 참조는 코드가 작성된 시점에 결정된다**
이러한 검색 과정은 전역 렉시컬 환경에 도달할 때까지 반복된다. 전역 렉시컬 환경의 **Outer Lexical Environment Reference**은 null을 가리키며, 이곳이 체인의 종점역이다. 전역 환경에서도 변수를 찾지 못하면 자바스크립트 엔진은 최종적으로 ReferenceError를 발생시킨다.

```js
// A. 전역 스코프의 렉시컬 환경
const x = 10;

function outer() {
  // B. outer 함수의 렉시컬 환경
  const x = 20;

  // 'inner' 함수는 이 (B) 스코프 내부에 '작성(정의)'되었습니다.
  function inner() {
    // C. inner 함수의 렉시컬 환경
    console.log(x); // 'x'를 검색합니다.
  }

  return inner;
}

function caller() {
  // D. caller 함수의 렉시컬 환경
  const x = 30; // 'inner' 함수를 호출하는 곳의 'x' 값

  // inner 함수를 호출합니다.
  const innerFn = outer();
  innerFn(); // <--- 여기서 호출됨. 결과는 무엇일까요?
}

caller();
```

inner 함수는 caller 함수 내부에서 호출되었지만, 스코프 체인은 caller 스코프를 포함하지 않는다. 오직 함수가 작성된 위치와 연결되어 있다는 것!

## 더 배울 것들

실행 컨텍스트의 이해를 바탕으로, 이 개념이 실제로 어떤 현상을 만들어내는지 집중하며 심화 학습을 진행하면 된다. 다음 장은, 실행 컨텍스트가 파괴되지 않고 유지되는 특별한 현상, 클로저 Closure에 대해 배워볼 것이다.

1. 클로저
   외부 함수가 실행을 마치고 해당 실행 컨텍스트가 소멸되어도, 내부 함수가 상위 스코프의 변수를 참조하고 있다면, 자바스크립트 엔진은 그 상위 함수의 렉시컬 환경을 메모리에서 파괴하지 않고 유지한다

2. this 바인딩
   this 바인딩은 실행 컨텍스트 생성 시점에 결정되지만, 그 결정 방식은 함수가 어떻게 호출되었는지에 따라 달라진다.

   - 일반 함수 호출
   - 메서드 호출
   - 생성자 함수 호출
   - call, apply, bind 메서드를 사용한 명시적 this 지정
   - 화살표 함수는 왜 this 바인딩이 만들어지지 않도록 태어난걸까? 왜 상위 스코프의 this를 상속하도록 설계된걸까?

3. 비동기 처리
   실행 컨텍스트 스택은 동기 코드의 실행 순서를 관리하지만, 자바스크립트의 비동기 코드는 어떤 로직을 통해 처리될까?
